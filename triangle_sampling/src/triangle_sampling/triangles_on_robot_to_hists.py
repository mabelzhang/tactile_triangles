#!/usr/bin/env python

# Mabel Zhang
# 30 Aug 2015
#
# Reads triangle CSV files recorded from tactile_collect triangles_collect.py.
#   Creates a histogram out of each CSV file.
#
# This file doesn't care about full path being in real.txt, it
#   just reads base name from csv_tri/ directory.
#
# This file computes histograms the SAME WAY as in
#   sample_pcl_calc_hist.py, by using write_hist_3d.py. Make sure
#   you always do this, so that files generated by the two files can be used
#   as training and test data for the same model!
# > TODO Just need to test the refactored version! Don't need to be on real
#   robot for this. Test when have time.
#

# Python
import csv
import os
import sys
from copy import deepcopy

import numpy as np

# My packages
from tactile_collect import tactile_config
from util.ansi_colors import ansi_colors
from triangle_sampling.load_hists import read_hist_config, \
  scale_bin_range_to_decimeter
from triangle_sampling.config_hist_params import TriangleHistogramParams as \
  HistP

# Local
from write_hist_3d import write_hist_3d_csv
from io_tri_csv import read_tri_csv_file


# To test on bare Python shell, opened in this directory:
'''
import triangles_on_robot_to_hists
# If need to reload:
#reload (triangles_on_robot_to_hists)

node = triangles_on_robot_to_hists.TrianglesOnRobotToHists()
node.read_config()
node.read_triangles ('2015-08-29-20-51-52_hand.csv')
'''
class TrianglesOnRobotToHists:

  # csv_suffix: '' for real robot data. 'gz_' for gazebo hand sampling. SHould always
  #   end in underscore, so that prune_triangle_outliers.py can replace _tri with
  #   pruned_tri.
  def __init__ (self, sampling_subpath, testKDE=False, csv_suffix='',
    custom_hist_conf_name=''):

    self.decimeter = HistP.decimeter
    print ('%sMeter to DECIMETER conversion set to %s%s' % \
      (ansi_colors.OKCYAN, self.decimeter, ansi_colors.ENDC))


    # Triangles path

    self.tri_subpath = 'triangle_sampling/csv_' + csv_suffix + 'tri/'
    # Real-robot tactile data, collected by triangles_collect.py
    # config_paths() creates the folder if it doesn't exist. Since this file
    #   is a reader, not a writer, don't create it. Just get the root path
    #   using config_paths(), then join to it without creating the folder.
    self.tri_path = tactile_config.config_paths ('custom', '')
    self.tri_path = os.path.join (self.tri_path, self.tri_subpath)


    # Histogram paths

    self.hist_path = tactile_config.config_paths ('custom',
      'triangle_sampling/csv_' + csv_suffix + 'hists/' + sampling_subpath)

    # If you run on mixed data, then you should pass in custom_hist_conf_name,
    #   specifying which file to use. Otherwise it can be confusing whether
    #   to use the PCL hist_conf.csv in csv_tri/, or the Gazebo hist_conf.csv
    #   in csv_gz_tri/.
    if custom_hist_conf_name:
      self.hist_conf_name = custom_hist_conf_name

    # The one in csv_*_hists folder, i.e. csv_gz_hists.
    else:
      self.hist_conf_name = os.path.join (self.hist_path, 'hist_conf.csv')


    # KDE paths

    self.testKDE = testKDE
    # config_paths() creates the folder if it doesn't exist. So don't create it
    #   unless we're actually outputting kde files (testKDE==True).
    if self.testKDE:
      self.kde_path = tactile_config.config_paths ('custom',
        'triangle_sampling/csv_' + csv_suffix + 'kde/' + sampling_subpath)


    # Book-keeping

    self.configured = False


  # For outside caller (hist_conf_writer.py) to call, in case no
  #   hist_conf.csv was saved (in case of Gazebo training), and caller doesn't
  #   need to save histograms, just want to look at the triangles data.
  def default_config (self):

    self.pr1 = HistP.PR1  #'l0'
    self.pr2 = HistP.PR2  #'l1'
    self.pr3 = HistP.PR3  #'a0'

    # These are passed to read_hist_config, use their defaults
    self.nbins = [10, 10, 10]
    self.bin_range3D = None

    self.configured = True


  # Parameters:
  #   decimeter: Let caller decide whether to use decimeters. e.g.
  def read_config (self, convert_to_decimeter=None):

    if convert_to_decimeter is None:
      convert_to_decimeter = self.decimeter

    # Read the histogram config file saved from point cloud sampling training,
    #   saved by sample_pcl_calc_hist.py, so real robot data can
    #   be binned to the SAME bins AS SYNTHETIC training, to realize "train
    #   synthetic, test real".
    # PCL bin ranges are already in decimeters. Gazebo bin ranges are in meters
    ((self.pr1, self.pr2, self.pr3), self.nbins, self.bin_range3D) = \
      read_hist_config (self.hist_conf_name)

    if convert_to_decimeter:
      _, self.bin_range3D = scale_bin_range_to_decimeter ( \
        None, self.bin_range3D, prs=(self.pr1, self.pr2, self.pr3))

      print ('%sRescaled bin ranges to decimeters: %s' % (\
        ansi_colors.OKCYAN, ansi_colors.ENDC))
      print ('%sMins:  %.2f %.2f %2.f%s' % (ansi_colors.OKCYAN,
        self.bin_range3D[0][0], self.bin_range3D[1][0], self.bin_range3D[2][0],
        ansi_colors.ENDC))
      print ('%sMaxes: %.2f %.2f %2.f%s' % (ansi_colors.OKCYAN,
        self.bin_range3D[0][1], self.bin_range3D[1][1], self.bin_range3D[2][1],
        ansi_colors.ENDC))

    self.configured = True


  # Parameters:
  #   tri_name: File full path, a .csv file in csv*_tri directory
  #   read_all_params: True for reading all 6 triangle parameters, not just
  #     the chosen 3.
  #   decimeter: Let caller decide whether to use decimeters. e.g.
  #     hist_conf_writer.py would NOT want to be in decimeters mode.
  # Returns NumPy 2D array of 3 x nTriangles size (or 6 x if read_all_params).
  #   Each of the 3 rows stores one parameter for all n triangles in the file.
  #   Now converted to a NumPy array of 3 x nTriangles.
  # Also returns a tuple of 3 (or 6 if read_all_params) strings for the
  #   triangle parameters read.
  def read_tri_csv (self, tri_name, read_all_params=False):

    if not self.configured:
      print ('TrianglesOnRobotToHists not configured. Call read_config() (if you have hist_conf.csv) or default_config() before calling read_tri_csv()!')
      return (None, None)

    # Specify 3 params
    if not read_all_params:
      params = (self.pr1, self.pr2, self.pr3)
      return read_tri_csv_file (tri_name, read_all_params, params)
    # Load all 6 params
    else:
      return read_tri_csv_file (tri_name, read_all_params)


  # Read one csv_tri file, writes histogram data.
  # Parameters:
  #   csv_base: Base name of a collected triangle CSV file,
  #     e.g. 2015-08-29-20-51-52_hand.csv
  #   csv_subdir: Immediate directory that csv_base file is in. e.g. object
  #     category folder.
  #   full_path: If True, then csv_base is the full path, instead of just
  #     basename.
  # Returns number of triangles (but not the actual triangles data).
  def read_triangles (self, csv_base, csv_subdir='', full_path=False):

    if not self.configured:
      self.read_config ()


    #####
    # Load triangle data, collected by tactile_collect triangles_collect.py
    #####
 
    print ('')

    if not full_path:
      # csv_base example: 2015-08-29-20-51-52_hand.csv
      trir_name = os.path.join (self.tri_path, csv_subdir, csv_base)
      basename = csv_base
    else:
      trir_name = csv_base
      basename = os.path.basename (csv_base)

    # 3 x nTriangles
    tris, _ = self.read_tri_csv (trir_name)
    if self.decimeter:
      tris = scale_tris_to_decimeters (tris, False)
    print ('l0 min: %g, max: %g' % (np.min (tris [0, :]), np.max (tris [0, :])))

    nTriangles = np.shape (tris) [1]

    self.write_histogram (tris.T, os.path.splitext (basename) [0], csv_subdir)

    return nTriangles


  # Parameters:
  #   tris: nTriangles x 3 NumPy 2D array. This will be passed to
  #     np.histogramdd(), must be n x d.
  #   filename: Base name to output histogram file to, without the extension,
  #     e.g. 2015-08-29-20-51-52_hand
  #   out_subdir: Immediate directory that output file is to be outputted,
  #     underneath the csv_*_hists folder. e.g. object category folder.
  def write_histogram (self, tris, filename, out_subdir=''):

    print ('triangles_on_robot_to_hists.py write_histogram() debug info:')

    #####
    # Compute histogram and save to file. This is test data for recognition
    #####
 
    print ('%d triangles' % np.shape(tris)[0])
    #print (tris)
 
    # TODO normed=False TEMPORARY for debugging. Flip to True for official
    #   data output.
 
    # Just compute histograms straight. See if some triangles from real robot
    #   don't fall into the bins from synthetic training data!
    #   If that is the case, that means your finger length fin_len in
    #   sample_pcl.cpp is too small. Most likely, the max of the bin range
    #   here is greater than the max of the bin range loaded from hist_conf.csv
    #   saved from synthetic training data.
    #   Then you just increase fin_len in sample_pcl.cpp, and rerun sampling
    #   on synthetic training data. Then try this again, and you should have
    #   all triangles fall into bins. Compare that by asserting 
    #   assert (number of nonzero elements in 3D histogram == number of triangles)
    '''
    histdd, edges = np.histogramdd (tris, normed=False)
    #print (np.shape (edges))
    print ('Bin mins: %f %f %f' % ( \
      np.min (edges [0][:]), np.min (edges [1][:]), np.min (edges [2][:])))
    print ('Bin maxes: %f %f %f' % ( \
      np.max (edges [0][:]), np.max (edges [1][:]), np.max (edges [2][:])))
    '''

    # Set to false if want to debug. This lets you see if total bin count is
    #   equal to the number of triangles. It checks if all triangles on real
    #   robot fit in bins from synthetic data.
    norm=True
 
    hist_name = os.path.join (self.hist_path, out_subdir, filename + '.csv')
    if not os.path.exists (os.path.dirname (hist_name)):
      os.makedirs (os.path.dirname (hist_name))
 
    hist_file = open (hist_name, 'wb')
    hist_writer = csv.writer (hist_file)
 
    # Use # bins and bin ranges in config file from training data
    histdd, _, hist_linear = write_hist_3d_csv (hist_writer, tris,
      bins=self.nbins, bin_range=self.bin_range3D, normed=norm,
      prs=(self.pr1, self.pr2, self.pr3))

    print ('Histogram written to %s' % hist_name)
 
 
    # Output debug info
 
    #print ('Reshaped to linear, dimensions:')
    #print (np.shape (hist_linear))
  
    print ('%d nonzero values in orig 3D hist' % len (np.nonzero (histdd) [0]))
    print ('%d nonzero values in linearized 3D hist:' % len (hist_linear [np.nonzero (hist_linear)]))
    #print (hist_linear [np.nonzero (hist_linear)])
 
    if not norm:
      print ('Sum of bin counts is %d, this should equal to number of triangles %d' % (\
        np.sum (hist_linear [np.nonzero (hist_linear)]), np.shape(tris)[0]))
    else:
      print ('(Set norm to False to see debug info about how many triangles fit into the synthetic bins.)')


    #####
    # Compute KDE and save to file. This is test data for recognition
    #####
 
    if self.testKDE:
      kde_name = os.path.join (self.kde_path, out_subdir, filename + '.csv')
  
      kde_file = open (kde_name, 'wb')
      kde_writer = csv.writer (kde_file)
 
      histdd, edgesdd, density_linear = write_hist_3d_csv ( \
        kde_writer, tris,
        bins=self.nbins, bin_range=self.bin_range3D, normed=True, kde=True,
        obj_name=filename, debug=self.testKDE, config_path=self.kde_path)


# Scale from meters to decimeters
# Parameters:
#   tris: Triangles data. 6 x nTriangles, or 3 x nTriangles, NumPy 2D array.
#   has_all_six_params: True if tris is 6 x _; will use constants L0_IDX,
#     L1_IDX, L2_IDX (i.e. 0, 1, 2) to scale those exact 3 params.
#     False if tris is 3 x _; will check each of pr1, pr2, pr3 to see which
#     is a length parameter, and scale just the length ones.
#   prs: List of 3 strings, the 3 chosen parameters. e.g. 'l0', 'l1', 'a0'.
#     If you use something different from the set defined in HistP, then pass
#     in your own.
def scale_tris_to_decimeters (tris_orig, has_all_six_params, prs=HistP.PRS):

  pr1, pr2, pr3 = prs

  tris = deepcopy (tris_orig)

  # Scale all length parameters to by 10
  if has_all_six_params:
    #print (HistP.L0_IDX)
    tris [HistP.L0_IDX, :] *= 10.0
    tris [HistP.L1_IDX, :] *= 10.0
    tris [HistP.L2_IDX, :] *= 10.0

  # Only scale L# lengths, not A# angles!
  else:
    if pr1 == HistP.L0 or pr1 == HistP.L1 or pr1 == HistP.L2:
      tris [0, :] *= 10.0
    if pr2 == HistP.L0 or pr2 == HistP.L1 or pr2 == HistP.L2:
      tris [1, :] *= 10.0
    if pr3 == HistP.L0 or pr3 == HistP.L1 or pr3 == HistP.L2:
      tris [2, :] *= 10.0

  return tris

